namespace GameClassLibrary

open System.Collections.Generic
open UnityEngine

// Visual: sky sphere yellow at top, white line/ fog line at the middle, blue bottom 
// + cartoony sun rendering (sunny color / night color), changes to night color (add star texture?)
// and moon shape rendering - visible in water reflection

// Game Level: grid of connected blocks appearing and dissapearing on aproach and distancing, each block is either blocked or free 
// set of entities generated for each block (enemies, obstacles, decals, events) 
// Block rendering: various block types, environments, flood fill environment prepetuation for themes (exhausts after count of similar 
// kind of blocks) water type, blocked type, ground type 

[<AutoOpen>]
module Libray = 
    let rnd = new System.Random();

    let NextRandom() =
        rnd.Next();

    type public Command =
        | PlayerMove of playerId : int32 * destination : Vector3 * frame : int32
        | PlayerAbility0 of playerId : int32 * destination : Vector3 * frame : int32

    type public PlayerKeybindings() =
        member val Ability0 = KeyCode.W;
        member val Move = KeyCode.Mouse0;

    type public MovableObject =
        struct
            val mutable position : Vector3
            val mutable rotation : Quaternion

            new (_position) =
                { position = _position; rotation = Quaternion.identity }

        member x.Move(destination) =
            x.position <- destination
            ()
        
        end

    let keybindings = new PlayerKeybindings()

    type public Player() =
        member val MovableObject = new MovableObject() with get, set
        member val Mana = 100.0f with get, set
        member val Id = NextRandom() with get, set
    
    // holds game state at one given time
    type public GameState() =
        do
            let mutable movableObject = MovableObject()
            movableObject.position <- Vector3.one
        
        member val Time = 0.0f with get, set
        member val Players : List<Player> = new List<Player>(4);

    // apply specific game rules modifying the game state
    type public GameMode() =

        // game mode is created with set of starting assets based on game mode rules and type of mode (single/multi/replay)
        // player is joined and created into game
        // when local player is created, local input is starting to get pooled from unity client
        
        // keep track of local unity client input commands
        let inputCommands = new List<Command>(4);

        // create fresh empty game state
        let gameState = new GameState()
        do
            // level init
            gameState.Players.Add(new Player())
        
        // keep track of local unity client input commands
        let getLocalCommands() =
            // get cursor location
            // get local player id
            // get next frame
            // populate as ready commands not input commands

            if (Input.GetKeyDown(keybindings.Move)) then
                inputCommands.Add(PlayerMove(0, Vector3(100.0f, 0.0f, 0.0f), 100))
            if (Input.GetKeyDown(keybindings.Ability0)) then
                inputCommands.Add(PlayerAbility0(0, Vector3(100.0f, 0.0f, 0.0f), 100))

        let mutable time = 0.0
      
        //play streams
        //elapsed->command list

        // static evaluate from replay
        // 
        member x.Update(elapsed) =
            let fixedTimeStep = 1.0 / 30.0
            time <- time + elapsed

            // if local player is playing, get input from unity
            getLocalCommands()

            // execute commands queued for this frame, update command timeline based on inputs from playing player, network, replay streams
            inputCommands
            |> Seq.iter (fun command ->
                match command with
                | PlayerMove(_) ->
                    gameState.Players.[0].MovableObject.Move(Vector3.zero)
                | PlayerAbility0(_) ->
                    ()
                )
            
            // clear processed commands 
            inputCommands.Clear()


            // visuals are kept up and keepen track of by client side unity code, each visual object[s] associated with game entity id
            // take game state, generate new visuals associated with game entity id where nessasery or use the existing object and refresh it
            // visual object is refreshed from game entity data, game entity provides and updates visual description, but does not know 
            // of implementation (need a way to generate event callback into visual?)

            // accumulate time and perform n fixed time updates each time processing input queue at that time 
            // input queue fed by commands generated by game link, replay data stream or network stream events
            
            // for single player:
            // get move and ability commands, feed them into simulator, simulate game state, update graphics state
            // for multi player:
            // get move and ability commands, send them to peer for verify, on recieve vertification feed the commands into simulator,
            // simulate the game state, update graphics state
            // for replay : take commands from list, feed them into simulator, simulate state, update graphics
            // for offline verify : take commands from list, feed them into simulator, compare claimed character state before and after simulation

            // move command: character id, destination location, frame called, frame to execute



            // if single player transform command requests from input into simulation commands, feed commands into simulation

                

            // players request abilities 250 ms after they call them and start playing local animation/visual cue
            // other players verify the request and send out ok message that executes the ability at agreed time(frame)
            // abilities arriving late are disregarded and miss message is sent out
            // if late ok message arrives ability is inserted at the timeline and simulation is redone
            // ability request method
            // ability exectute method
            // ability ok method
            // ability miss method


            ()
        member x.Input(command) =
            ()

    type public UnityGameLink() =
        inherit MonoBehaviour()

        let gameMode = new GameMode()

        member x.Start() =
            Debug.Log("UnityGameLink Started...")
            // Create and start appropiate game mode like - single player for start
            ()
        member x.Update()=
        
            let time = float Time.deltaTime
            let totalTime = Time.time
            //Debug.Log("time")

            gameMode.Update(time)

            //create and maintain game mode

            //feed input as commands to game mode

            //build and maintain visual representation from game mode state

            ()